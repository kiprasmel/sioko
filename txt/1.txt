#include <IRremote.h>

//Pultelio hex kodai ir nustatymai
#define Number1  0xFF906F
#define Number2  0xFFB847
#define Number3  0xFFF807
#define Number4  0xFF9867
#define Number5  0xFFD827
#define Number6  0xFF8877
#define Number7  0xFFE817
#define Number8  0xFF48B7
#define Number9  0xFF9A65
#define Enter    0xFFE01F
#define MY_PROTOCOL NEC;

//Siustuvo nustatymai
const byte RECV_PIN = 23;
IRrecv irrecv(RECV_PIN);
decode_results results;
int etr = 0;

byte myLINE  = B0000;
byte myLINEBACK  = B00;
byte mySIDES = B000000;//8
byte myFRONT = B000000;
byte myMOUSE = B00;//8

//varikliu pajungimas
const byte PWM1 = 7;
const byte PWM2 = 9;
const byte DIR1 = 6;
const byte DIR2 = 10;

//Linijos sensoriai
const byte LeftLine1 = 35;//rau
const byte LeftLine2 = 36;//g

const byte RightLine1 = 37;//ru
const byte RightLine2 = 38;//z

const byte RightBackLine = 31;
const byte LeftBackLine = 32;

//puolimo sensoriai
const byte Rightback = 15;
const byte Right1 = 23;
const byte Right2 = 22;
const byte Right3 = 21;
const byte Middle1 = 20;
const byte Middle2 = 19;
const byte Middle3 = 33;
const byte Left3 = 18;
const byte Left2 = 17;
const byte Left1 = 16;
const byte Leftback = 34;
//const byte Back = 14;

int k=0;
int b=0;

//nep right
//33
//34
//nep left
//15
//14
const byte START_MODULE = 29;

//Varikliu greiciai
const byte SPEED_NORMAL = 200;
const byte SPEED_TURN = 160;
const byte SPEED_TURN2 = 150;
const byte SPEED_GO_BACK_LINE = 255;
const byte SPEED_GO_BACK_LINE_TURN = 200;
const byte SPEED_GO_BACK_LINE_TURN2 = 200;

//atsitraukimo ir pasisukimo atsitraukiant laikai priekiniu linijos
const unsigned short TIME_FOR_GO_BACK = 70;//60
const unsigned short TIME_FOR_GO_BACK_1 = 90;//105

byte START_STRATEGY_STATE = 0;
byte MAIN_STRATEGY_STATE = 0;

//Milis
unsigned long time;

bool Front = false;


byte check;

void setup() {
  Serial.begin(9600);

  pinMode(13, OUTPUT);
  
  pinMode(PWM1, OUTPUT);//PWM1
  pinMode(PWM2, OUTPUT);//PWM1
  pinMode(DIR1, OUTPUT); //DIR1
  pinMode(DIR2, OUTPUT); //DIR2

  pinMode(LeftLine1, INPUT); //LeftLine1
  pinMode(LeftLine2, INPUT); //LeftLine2
  pinMode(RightLine1, INPUT); //RightLine1
  pinMode(RightLine2, INPUT); //RightLine2
  
  pinMode(LeftBackLine, INPUT);
  pinMode(RightBackLine, INPUT);

  pinMode(Rightback, INPUT);
  pinMode(Right1, INPUT); 
  pinMode(Right2, INPUT); 
  pinMode(Right3, INPUT); 
  pinMode(Middle1, INPUT); 
  pinMode(Middle2, INPUT); 
  pinMode(Middle3, INPUT); 
  pinMode(Left3, INPUT); 
  pinMode(Left2, INPUT); 
  pinMode(Left1, INPUT); 
  pinMode(Leftback, INPUT);
  //pinMode(Back, INPUT);
  
  analogWriteFrequency(9, 15000);
  analogWriteFrequency(7, 15000);

  irrecv.enableIRIn();
  IR_Remote();

  pinMode(START_MODULE, INPUT);
  while (true) {
    if (digitalRead(START_MODULE)) {
      break;
    }
    Jutikliu_duom();
    if (myFRONT != 0b000000) {
      digitalWrite(13, HIGH);
    } else {
      digitalWrite(13, LOW);
    }
  }
  delay(2000);
  Start_Streategy();
}

//------------------------------------------------------------------------------
void loop() {
  Jutikliu_duom();
  Line();
  switch(MAIN_STRATEGY_STATE)
  {
    case 1:
      switch(myFRONT){
          case 0b10000:
          case 0b11000:
           SpinLeft(SPEED_TURN, 0.1);
          break;
          case 0b00001:
          case 0b00011:
           SpinRight(SPEED_TURN, 0.1);
          break;
          case 0b00000:
            Jutikliu_duom();
            Line();
            switch(mySIDES)
            {
              case 0b000000:
                Jutikliu_duom();
                Line();
              break;
              case 0b001000:
              case 0b111000:
              case 0b101000:
              case 0b011000:
                SpinLeft(SPEED_TURN, 10);
              break;
              case 0b000100:
              case 0b000110:
              case 0b000111:
              case 0b000101:
                SpinRight(SPEED_TURN, 10);
              break;
              case 0b010000:
                SpinLeft(SPEED_TURN, 5);
              break;
              case 0b000010:
                SpinRight(SPEED_TURN, 5);
              break;
              case 0b110000:
              case 0b100000:
                SpinLeft(SPEED_TURN, 40);
              break;
              case 0b000011:
              case 0b000001:
                SpinRight(SPEED_TURN, 40);
              break;
            }
          break;
          default:
            time = millis();
            while (millis() - time <= 100 && digitalRead(Middle1) == 0 && digitalRead(Middle2) == 0 && digitalRead(Middle3) == 0)
            {
              motor(255, 255);
            }
          break;
          }
  }
}
void motor(int a, int b) {
  a = constrain(a, -255, 255);
  b = constrain(b, -255, 255);

  if (a <= -1 )//&& a > -255
  {
    digitalWrite(DIR1, 1);
    analogWrite(PWM1, (255-abs(a)));
  } else if (a >= 1 )
  {
    digitalWrite(DIR1, 0);
    analogWrite(PWM1, a);
  } else if (a == 0)
  {
    digitalWrite(DIR1, 0);
    analogWrite(PWM1, 0);
  }

  if (b >= 1 )//&& b > -255
  {
    // b = map(abs(b), 0,255,255,0);
    digitalWrite(DIR2, 0);
    analogWrite(PWM2, b); // 255 -
  } else if (b <= -1 )//&& b < 255
  {
    digitalWrite(DIR2, 1);
    analogWrite(PWM2, (255 - abs(b)));
  } else if (b == 0)
  {
    digitalWrite(DIR2, 0);
    analogWrite(PWM2, 0);
  }

}
int Jutikliu_duom() {
  for (int i = 0; i <= 9; i++) {//9
    bitClear(myLINE, i);
    bitClear(myFRONT, i);
    bitClear(mySIDES, i);
  }
  //Sonai
  
  //if (digitalRead(Rightback) == 0)  bitSet(mySIDES, 0);
  if (digitalRead(Right1) == 0)     bitSet(mySIDES, 1);
  if (digitalRead(Right2) == 0)     bitSet(mySIDES, 2);
  if (digitalRead(Left2) == 0)      bitSet(mySIDES, 3);
  if (digitalRead(Left1) == 0)      bitSet(mySIDES, 4);
  //if (digitalRead(Leftback) == 0)   bitSet(mySIDES, 5);

  //Priekis
  if (digitalRead(Right3) == 0)     bitSet(myFRONT, 0);
  if (digitalRead(Middle1) == 0)    bitSet(myFRONT, 1);
  if (digitalRead(Middle2) == 0)    bitSet(myFRONT, 2);
  if (digitalRead(Middle3) == 0)    bitSet(myFRONT, 3);
  if (digitalRead(Left3) == 0)      bitSet(myFRONT, 4);

  /*if (digitalRead(Right1) == 0) bitSet(myFRONT, 6);
  if (digitalRead(Right2) == 0) bitSet(myFRONT, 5);*/
  /*if (digitalRead(Right3) == 0) bitSet(myFRONT, 4);
  if (digitalRead(Middle2) == 0) bitSet(myFRONT, 3);
  if (digitalRead(Left3) == 0) bitSet(myFRONT, 2);*/
  /*if (digitalRead(Left2) == 0) bitSet(myFRONT, 1);
  if (digitalRead(Right1) == 0) bitSet(myFRONT, 0);*/
  
  //Linija
  if (digitalRead(LeftLine1) == 1)    bitSet(myLINE, 3);
  if (digitalRead(LeftLine2) == 1)    bitSet(myLINE, 2);
  if (digitalRead(RightLine1) == 1)   bitSet(myLINE, 0);
  if (digitalRead(RightLine2) == 1)   bitSet(myLINE, 1);

}

void Line()
{
  //Back = false;
  //Linija
  switch (myLINE)
  {
    case 0b0011://Right
      time = millis();
      while (millis() - time <= TIME_FOR_GO_BACK)
      {
        motor(-SPEED_GO_BACK_LINE, -SPEED_GO_BACK_LINE);
        //Jutikliu_duom_back();
        if(myLINEBACK != 0b00)
        {
          break;
        }
      }
      time = millis();
      while (millis() - time <= TIME_FOR_GO_BACK_1)
      {
        motor(-SPEED_GO_BACK_LINE_TURN, SPEED_GO_BACK_LINE_TURN2);
        //Jutikliu_duom_back();
        if(myLINEBACK != 0b00)
        {
          break;
        }
      }
    break;
    case 0b1100://Left
      time = millis();
      while (millis() - time <= TIME_FOR_GO_BACK)
      {
        motor(-SPEED_GO_BACK_LINE, -SPEED_GO_BACK_LINE);
        //Jutikliu_duom_back();
        if(myLINEBACK != 0b00)
        {
          break;
        }
      }
      time = millis();
      while (millis() - time <= TIME_FOR_GO_BACK_1)
      {
        motor(SPEED_GO_BACK_LINE_TURN, -SPEED_GO_BACK_LINE_TURN2);
        //Jutikliu_duom_back();
        if(myLINEBACK != 0b00)
        {
          break;
        }
      }
      break;
    case 0b1111://Both
      time = millis();
      while (millis() - time <= TIME_FOR_GO_BACK)
      {
        motor(-SPEED_GO_BACK_LINE, -SPEED_GO_BACK_LINE);
        //Jutikliu_duom_back();
        if(myLINEBACK != 0b00)
        {
          break;
        }
      }
      time = millis();
      while (millis() - time <= TIME_FOR_GO_BACK)
      {
        motor(-SPEED_GO_BACK_LINE_TURN, SPEED_GO_BACK_LINE_TURN2);
        //Jutikliu_duom_back();
        if(myLINEBACK != 0b00)
        {
          break;
        }
      }
      break;
    case 0:
      motor(SPEED_NORMAL, SPEED_NORMAL);
      break;
  }
}
void SpinRight(int a, int t)
{
  time = millis();
  while (millis() - time <= t && (digitalRead(Middle1) == 1 or digitalRead(Middle2) == 1 or digitalRead(Middle3) == 1))
  {
    motor(a, -a);
  }
}
void SpinLeft(int a, int t)
{
  time = millis();
  while (millis() - time <= t && (digitalRead(Middle1) == 1 or digitalRead(Middle2) == 1 or digitalRead(Middle3) == 1))
  {
    motor(-a, a);
  }
}